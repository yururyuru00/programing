課題1_1
main関数の中身について記述した
主にこれから構文解析をするために必要な変数や、構文解析自体を
している関数について、宣言するタイミングや関数はどの引数を渡
して呼ぶか、などについて考えた
この時は何をしているのか全く分からなかったが、課題をすべてや
り終えた後は、それぞれの変数や関数の意味や働きについて少しわ
かるようになったので行っていることが少し把握できた

課題1_2
コンパイル後にVSMファイルに適切なVSMコード(しかしこの時点で
はmain関数の番地やglobal変数領域についてわからないため、初
期値)が生成できるように、あらかじめ用意されているcode_関数
を用いてコーディングした。
付録7_4によると、code_append()がVSM命令の追加で、code_set
()がすでにある命令について上書きする関数という事が分かった。
preprocessでわかる範囲でVSM命令を追加し、最後に分かったこと
(mainの先頭番地やglobal変数の領域)を用いてVSMコードを上書き
する流れだという事が分かった

課題1_3
parse_programという変数宣言や関数宣言、さらにその関数の引数
や中の実行処理などを解析する大元の関数について、そもそも私た
ちが取り扱うプログラムの文法構造を把握しながら、頭部→尾部の順
に構文解析ができるようにコードを付け足した。
最初は何をしているのかさっぱりだったが、
頭部...条件にかかわらず必ず存在するのでif分なしでまず解析する
この解析はparse_declaration_headに任せる
尾部...頭部の解析が終わった後の直後のtokenが'('なら関数
それ以外なら変数宣言という点からif分で分岐させる
関数宣言の解析はparse_function_declaration_tail()
変数宣言の解析はparse_variable_declaration_tail()に任せる

という代替の流れが分かった。
複雑なプログラムであればあるほど、場合分け、さらにその分野の
役割ごとに関数を新たに用意し受け渡す枝分かれ構造をとることが
大切だという事が分かった。大きなプロジェクトを行うときに、た
くさんの課があり、それぞれが密接につながり仕事を分担し、社長
というmain関数が各課(関数)を動かしていりイメージを持った

課題1_4
課題1_3で言った、頭部の解析を行う関数parse_declaration_head
について細かく記述を行う課題だった。
しかしこの課題も同じく、今度は宣言頭部とはどのような文法構造な
のか、という観点を持ちながらどのような順番で、どのような場合分
けを行いながら解析していくかということを考える点では1_3と似た
ことをしているような感覚にもなった

具体的には今回のmini_Cコンパイラで取り扱う変数が
char, int, ポインタ変数、変数
がすべてのため、与えられた変数がchar intと分けてから、その変数
がポインタ変数でなければlevel0、ポインタ変数であれば参照する回
数分だけlevelをあげるという分岐の構造でコーディングした

課題1_5
課題1_3でいった変数宣言の尾部の解析を行うparse_variable_decla
ration_tailについて完成させた
変数宣言の尾部は[]しかないためそれについての解析を行う。
具体的には、何次元配列(つまり[]がいくつか)かわからないため、'['
を見つけたら中の変数について値をとって配列に保持しておき"]"を確
認。これを１サイクルとしたwhileループを行い、'['の記号がなくなる
まで、つまり[]の右端までこのサイクルを繰り返す
繰り返し終わると自然とすべての[]の中身の値(何行、何列などにあたる
)をすべて保持した配列が出来上がるためこれを使って配列のサイズを計
算した。
その後、tab_t型構造体の各メンバ変数にptrlevelやbasetype,sizeな
ど様々な情報を登録することで、tab_t型構造体に変数に関する様々な情
報を与えていることがわかった。
初めはtab_tが急に出てきたため、全く分からなかったが、この構造体へ
の登録手続きを行っているのはmcc.cのどの部分化を探してみると
parse_function_declaration_tail
parse_variable_declaration_tail
の最後にしかなかったことが分かった。
そしてそもそも、プログラムの各宣言は変数宣言か関数宣言の必ずどち
らか二択のためその二つの宣言の尾部、つまり最後を解析するこの二つ
の関数の最後にこの登録手続きを行うことは、すべての変数、関数に対
して得られた情報をtab_t型の構造体に登録して、tab_dumpで今まで
登録されてきたすべての変数、関数についての様々な情報を表のように
一気に開示する。という流れなのかと考えた。

課題1_6
この課題では
parse_declaration_head1()
parse_variable_declaration_tail()
つまり変数の頭部と尾部の解析を続けて行う、いわば変数専門の構文
解析関数を作った。初めは何に使うのか、なぜそのようなものを使う
のかわからなかった。
しかし実際は
int function(int a, int b, ...) {
int x[][];
int **y;
.
.
.
}
のような変数a, b, ..., x, y...に対して用意されていることが分かった
これらの変数の特徴として
⓵確実に変数、関数は考えられない
⓶int functionという関数について解析中(つまりparse_function_
declaration_tail)の途中にこのような新たな変数が現れるため
今までのようにこれらの変数に対してparse_program関数で構文解釈が
できない

という特徴があるためこれらのために新たな変数宣言専門の構文解釈関数
をわざわざ用意し、これらの変数に対しては別個の関数を使ったのかな,
と思った

課題1_7
関数宣言の尾部を解析する関数
parse_function_declaration_tail
の完成をさせる課題を行った。今までの課題と同じく関数宣言の尾部とは
そもそもどんな構造をとっているかという事を考えながらコーディングを
行った。
ここで思ったこととして記号表を表示するための情報を格納、保持する構
造体gt, ltに関して
parse_variable_declaration_tailではグローバル変数用の表のための
構造体gtしか扱っていないのに対して、
parse_function_declaration_tailでは引数として受け取ったgtの他に
関数内でltという構造体を新たに定義していて、ローカル、グローバル二
つの構造体を用意していた。これに関しては、関数宣言の外で宣言する変
数宣言は必ずグローバル変数になるから
parse_variable_declaration_tailではgtしか必要ないが、main関数や
他の関数事態はグローバル変数だが、関数の中身の変数宣言に関してはロ
ーカル変数になるような一つの関数宣言の解析に対し、ローカル、グロー
バル二種類を取り扱う状態になるときはlt, gt二つ必要という事が分かっ
た。

課題1_8
1_7に引き続き、関数内のローカル宣言やローカル宣言を解析したあとの
様々な分の解析を行う関数
parse_function_bodyのコーディングを行った。
序盤では頭が"int", "char"のどちらかが来たら必ず変数宣言という点か
ら、そのたびに変数宣言の解析専門の
parse_variable_declarationを呼び出し解析している

課題1_9
preprocessの時点ではわからなかったglobal変数領域のサイズやmain
の先頭番地が分かったことから、それを使って正しいVSMコードが書け
るような命令を行った。この分野は前回のVSMコードの課題のフレームに
ついてしっかり理解する必要があったためまた一度復習しなおしてから
もう一度取り組んでみたい
