科目名: コンパイラ実習
課題: R5
番号: 6689
氏名: 矢嶋　悠太
作成: 2018年10月15日

----------------------------------------

[課題 5.8]
St if を実装せよ.
1. クラスの宣言をast.h に追加せよ.
2. print の実装をast.cpp に追加せよ.
3. 次のif 文を表す抽象構文木を構築して表示するプログラム5 08.cpp を
作成せよ.

[実行結果]
user@user-THINK /cygdrive/c/programing/Compirer_training/R5b
$ ./a
  if(i<0){
    s = (s-i);
  }
  else {
    s = (s+i);
  }


実装に関しては苦労することはなかったが、出力に関してきれいにインデントが
を出すようにしてプログラムすることに少し苦戦した
たとえば図のように
if() {
	s = ...
     }

の二個目の"}"のインデントの位置を正しく行うことに少し考えることになった
自分なりに考えた手法としては St_ifクラスの中のprint()メソッドについて


----------------------------------------

[課題5.9]
St while を実装せよ.
1. クラスの宣言を ast.h に追加せよ.
2. print の実装を ast.cpp に追加せよ.
3. 次の while 文を表す抽象構文木を構築して表示するプログラム 5 09.cpp を
作成せよ.

[実行結果]
user@user-THINK /cygdrive/c/programing/Compirer_training/R5b
$ ./a
while(i<=n){
    if(i<0){
      s = (s-i);
    }
    else {
      s = (s+i);
    }
    i = (i+1);
}


この実装も特に工夫などした点はなかったが、上の実行結果の様にwhileの中に
ifの抽象構文木を構成してもインデントが
"{"
を行うたびに次の行で一個分増やされて行われ、
"}"
を行うたびに次の行で一個分減らされて行われいるため正しく行われていること
に関しては満足がいく結果になった。
方法としては非常に単純で、St_ifやSt_Whileのprintメソッドの中で"{"を出力す
るシーンになればその次の行はインデントをさらに増やしてずらす必要があるた
め、os << "{";　のあとにindent++; を行う様にし、
"}"がくればその行は前の行よりインデントを一つ減らして逆にずらす必要がある
ため、indennt--; をしてから　改行を行い　os << "}";を行う様にした


--------------------------------------------

[課題5.10]
St return を実装せよ.
1. クラスの宣言を ast.h に追加せよ.
2. print の実装を ast.cpp に追加せよ.
3. 次の return 文を表す抽象構文木を構築して表示するプログラム 5 10.cpp を作成せよ.
return s;
4. 正しく表示が行われることを確認せよ.

[実行結果]
user@user-THINK /cygdrive/c/programing/Compirer_training/R5b
$ ./a
return s;


上の様に正しく動作していることが確認できた。
この課題に関しては特に苦労したことはなかったがそれはこれが単なるprintメソ
ッドだからであって、実装という事になればややこしいという事が考えられた
例えば変数"s"を返すとしてその変数sがExpressionというクラスのどの派生クラス
のインスタンスにアクセスしたらよいかなどいろいろとややこしそうだと感じた

---------------------------------------------

[課題5.11]
 St function を実装せよ.
1. クラスの宣言を ast.h に追加せよ.
2. print の実装を ast.cpp に追加せよ.
3. 次の関数呼び出し文の抽象構文木を構築して表示するプログラム 5 11.cpp を作成せよ.
putint(a);
4. 正しく表示が行われることを確認せよ


[実行結果]
user@user-THINK /cygdrive/c/programing/Compirer_training/R5b
$ ./a
putint(a, (a+x));

上の様に正しく実行結果が得られた

この課題では新たに包含という方法を学んだ
主な実装法相としては、先に元のExp_funtionインスタンスを作っておいて元の
Exp_functionと被っている要素はその作っておいた、メンバ変数であるExp_fun
ctionインスタンスを使って出力などを行い、違う所だけ書き加えるようにする
事であった。初めて習う方法だが、元のクラスと違う役割だけ書き加えていく
流れは継承に似た印象を受けたため割とスムーズにプログラムすることが出来た


---------------------------------------------

[課題5.12]
2 Variable を実装せよ.
1. クラスの宣言を ast.h に追加せよ.
2. print の実装を ast.cpp に追加せよ.


user@user-THINK /cygdrive/c/programing/Compirer_training/R5b
$ ./a
int a

正しい実行結果が得られた。
レジュメで書いてあるようにインデントの++, -- や改行などはどこで行うか
という事に気を付けないと呼び出し元と呼び出し先で二重に起きてしまうという
ケースが考えられるため、これに関しては抽象構文木の階層を意識しながら行う
ことが大切だということが分かった。それを意識してプログラムを行うとある
程度きれいにインデントが行われ、正しく改行もされていた事が確認できた。


-------------------------------------------

[課題5.13]
Function を実装せよ.
1. クラスの宣言を ast.h に追加せよ.
2. デストラクタと print の実装を ast.cpp に追加せよ.
3. [List 5.2] の関数の構文木を構築するプログラム 5 13.cpp を作成せよ. (以前の課題で作成した make while
を再利用せよ.) この関数宣言の抽象構文木を以降の演習で再利用するので, この抽象構文木を構築する部分
を関数 Function* make function asum() として独立させよ.
4. 実行して正しい表示が得られることを確認せよ.

[実行結果]
user@user-THINK /cygdrive/c/programing/Compirer_training/R5b
$ ./a
int asum(int n)
{
  int s;
  int i;

  s = 0;
  i = (-n);
  while(i<=n){
      if(i<0){
        s = (s-i);
      }
      else {
        s = (s+i);
      }
      i = (i+1);
  }
  return s;
}

正しく動作していることが確認できた
ただ一つ課題としては、インデントは行われているのだが、
while() {
    if() ...
のようにwhileからifに移るときインデントが二回更に行われてしまっているの
でもう一度プログラムを見返して、どこで二重にindent++ が行われているのか
原因解析をしっかりして修正していきたい
またfunction関数について、これのメンバ変数に
Statement* body_;
というStatementオブジェクトを参照するポインタ変数があったがこれはSt_list
クラスのオブジェクトを参照するようにすれば、必要な分の構文が関数の中から実行、呼び出せることが分かった

------------------------------------

[課題5.14]
Program を実装せよ.
1. クラスの宣言を ast.h に追加せよ.
2. デストラクタと print の実装を ast.cpp に追加せよ.
3. 次の [List 5.3] の関数の構文木を構築するプログラム 5 14.cpp を作成せよ.
(前の課題で作成した make function asum を再利用せよ.)
4. 実行して正しい表示が得られることを確認せよ.

[実行結果]
user@user-THINK /cygdrive/c/programing/Compirer_training/R5b
$ ./a
  int g;
  int asum(int n)
{
  int s;
  int i;

  s = 0;
  i = (-n);
  while(i<=n){
      if(i<0){
        s = (s-i);
      }
      else {
        s = (s+i);
      }
      i = (i+1);
  }
  return s;
}
int main()
{
  int a;

  g = asum(g);
}

正しく動作していることが確認できた
最初はmain関数もfunctionのリストであるfuncs_に入れればいいと思っていたが、この後の実相のことも併せて考えればほかの関数軍とmain関数は分けて定義する方がよいと感じた。実装に関して特に苦労した点はなかった。これで一通りの抽象構文木の構成をprintすることが可能になったことが分かった

-------------------------------------

[課題5.15]

講義ホームページより factor.cpp をダウンロードし, ast.cpp とリンクして実行し, 下のような結
果が得られることを確認せよ.

[実行結果]
user@user-THINK /cygdrive/c/programing/Compirer_training/R5b
$ ./a
  char separator;
  int factor(int n)
{
  int d;

  d = 2;
  while((d*d)<=n){
    if((n%d)==0){
        putint(d);
        putchar(separator);
        n = (n/d);
    }
    else {
        d = (d+1);
    }
  }
  putint(n);
  putchar('\n');
}
int main()
{
  int n;

  putchar('n');
  putchar('=');
  n = getint();
  separator = '*';
  factor(n);
}

レジュメの出力結果とほぼ同じように出力されていることが確認できた。


---------------------------------------
[全体の感想]
今回の課題では実装はできたが、一つ一つの構文について具体的にどういった処理がなされているのかが分かり辛く、構文がややこしく感じてしまったが、授業でTAの方々に質問をしていく内に少しずつ分かるようになった。
c++は構文や考え方などは分かり辛く感じることもあるもののｍ慣れてくるとcでできなかったことが出来るようになってくる感じを受け、しっかりと慣れれば効率の良い見やすいプログラムを書くことが出来るような気がした
これからの実習を通してより熟練できるようになりたい




