科目名: コンパイラ実習
課題: R3
番号: 6689
氏名: 矢嶋悠太
作成: 2018年10月5日

----------------------------------------

[課題 3.1]

[List 3.1] は, aaa, bbb, ccc と言う 3 つの
クラスについて, コンストラクタ, デストラクタが
呼ばれる毎にその旨を表示するようにしたものであ
る. このプログラムを実行し, 結果を分析せよ. (
実行結果の各行に対して, そのコンストラクタ, デ
ストラクタがプログラム中のどこでどのように呼ば
れたか説明せよ.)

[実行結果]
user@user-THINK /cygdrive/c/programing/Compirer_training
$ ./a
aaa() --- aaa a; からクラスaaaのコンストラクタ呼び出し
bbb() --- bbb x[0]; からクラスbbbのコンストラクタ呼び出し
bbb() --- bbb x[1]; からクラスbbbのコンストラクタ呼び出し
bbb() --- bbb x[2]; からクラスbbbのコンストラクタ呼び出し
aaa() --- p = new aaa; からクラスaaaのコンストラクタ呼び出し
aaa(3,4) --- a = aaa(3, 4); からクラスaaaの引数付きコンスト
ラクタ呼び出し
∼aaa() --- a = aaa(3, 4)で用意された一時変数が式の評価が
終わったため消滅させるため右辺のaaaクラスのデストラクタが
呼ばれた
aaa(7,4)
∼aaa()
aaa(7,4)
∼aaa()
aaa(7,4)
∼aaa() --- for文で三回セットでコンストラクタとデストラクタを
読んでいる
∼aaa() --- newで割り当てられた変数をdeleteで排除するため
デストラクタを読んでいる
aaa()
bbb()
ccc() ---上三つはccc c;からクラスccc内でaaa p, bbb qと宣言
しているためコンストラクタが呼ばれている。さらにcccクラスの
コンストラクタが呼ばれているためこの三つが表示される
∼ccc()
∼bbb()
∼aaa()
∼bbb()
∼bbb()
∼bbb()
∼aaa() --- この順番から分かるようにデストラクタは新しく作ら
れた変数から消滅し、デストラクタが呼ばれていることが分かった

-------------------------------
[課題3.2]
trace を実際に使用してみよ. [List 3.6] のプログラムを実行
し, 予想と結果を比較せよ.

[実行結果]
main begin
for-loop begin
add begin
add end
for-loop end
for-loop begin
add begin
add end
for-loop end
for-loop begin
add begin
add end
for-loop end
main end

予想通りの結果を得られた。この課題ではコンストラクタとデストラ
クタを効果的に使って、各タスク(main, for, add)の始まりから終
わりまでを表していた。この課題からも分かるように、変数が生存す
る範囲は{}ないという事も、コンストラクタとデストラクタの呼び出
すタイミングからも確認ができた

-------------------------------
[課題3.3]
Complex に対して, 代入演算, および左辺に右辺の値を足し込む演
算 += を定義し, 動作を確認せよ.
(定義の方法は代入とほぼ同様である.)

[実行結果]
$ ./a
1.2+1.5i
2.9+4.6i

正しく動作していることが確認できた

--------------------------------
[課題3.4]
[List 3.7], [List 3.8] のプログラムを実行し, どのよう
な結果になるか確認せよ.

[実行結果]
max=5, sp=3, data=(1 300 500 )
max=5, sp=3, data=(1 300 500 )
Aborted (コアダンプ)

-------------------------------
[課題3.5]
stack に対する代入関数を定義し, 課題 3.4 のプログラムが
きちんと動くようにせよ

[実行結果]
max=5, sp=3, data=(1 300 500 )
max=7, sp=3, data=(1 3 5 )

r3_4.cppではポインタ変数での残照のコピーを行っていたため
デストラクタの二回呼び出しによりにより同じ場所を二重に領
域開放することになったためコアダンプが起きてしまったことが
分かった
r3_5.cppではその課題の対策として参照のコピーではなく配列
同士の値のコピーを行ったため、二つのスタッククラスのdate
という配列のポインタが異なり、デストラクタによる領域開放
でも、二重に同じ場所を解放する、という事を避けれたためエ
ラーがなくなり実行ができるようになった

------------------------
[課題3.6]
次の [List 3.17] は, Complex のコンストラクタ, デストラク
タ, 代入演算の起動に際してメッセージを出すようにしたもので
ある. 実行結果について, どの呼出しがプログラム中のどの部分
で行われたものか説明せよ.
(プログラムは, ダウンロードせよ. プログラムを添付する必要
はない)

[実行結果]
Complex(3.14,2.26) --- Complex x(3.14, 2.26)による引数
付きコンストラクタの呼び出し
Complex(const Complex&) --- Complex y = x;によるコピー
コンストラクタの呼び出し
Complex() --- Complex z;によるコンストラクタの呼び出し

Complex(const Complex&)
Complex(const Complex&)
--- z = x + yの右辺の式の評価に
よってoperator+が呼び出される。引数は(Complex a, Complex b)
だが、main側で(x, y)でクラスを渡しているため
Complex a = x;
Complex b = y;
のように値の引数への引き渡しが行われ、この時コピーコンストラ
クタが呼ばれる

Complex() --- operator+メソッドの一行目: Complex c;より
によるコンストラクタの呼び出し
operator=(const Complex& c) --- 右辺の式の評価が終わったた
め、次に z = x + y;のoperator=メソッドが呼ばれる
~Complex()
~Complex()
~Complex() --- 代入分の実行終了とともに一時変数の庄メル
6.28+4.52i
~Complex()
~Complex()
~Complex() --- 三変数x, y, zの消滅

---------------------------------
[課題3.7]
List 3.18] のプログラムでどのようなエラーが出るか確認せよ.

[実行結果]
max=5, sp=3, data=(-2144485400 1 -2144485400 )
max=5, sp=3, data=(2 4 6 )
max=10, sp=6, data=(1 3 5 2 4 6 )
Aborted (コアダンプ)

----------------------------------
[課題3.8]
コピーコンストラクタを追加し, [List 3.18] のプログラム
にせよ.

[実行結果]
max=5, sp=3, data=(1 3 5 )
max=5, sp=3, data=(2 4 6 )
max=10, sp=6, data=(1 3 5 2 4 6 )

---------------------------------
[課題3.9]
これまでに作成した Complex, stack の最も新しいバージョン
のコンストラクタを「引数つきコンストラクタ」を用いた構文
に書き直せ. (Complex のプログラムを 3 9c.cpp に, stack
のプログラムを 3 9s.cpp にそれぞれ添付せよ.)

max=5, sp=3, data=(1 3 5 )
max=5, sp=3, data=(2 4 6 )
max=10, sp=6, data=(1 3 5 2 4 6 )

6.28+4.52i

共に正しい結果が得られた

-----------------------
[課題R3の感想]
コピーコンストラクタについて、書式から理解まで時間がかかって
しまった。ただコピーコンストラクタは無意味な初期化などを避け
るためのコンストラクタという事を考えながらデフォルトのコピー
コンストラクタのコードなどを見てみると少し理解ができた。
クラスやメソッドなどの一つ一つのシステムについて、漠然と勉強
するのではなく、何を目的にできたのか、という事を考えながら、
取り組んで勉強するように心がけたい
