科目名: コンパイラ実習
課題: R5a
番号: 6689
氏名: 矢嶋　悠太
作成: 2018年10月12日

----------------------------------------

[課題 5.1]
定数 7, ’x’ に対する抽象構文木を構築し, 表示するプロ
グラム 5 01.cpp を作成し, 動作を確認せよ.


user@user-THINK /cygdrive/c/programing/Compirer_training/R5a
$ ./a
7
'x'

正しく表示されていることが確認できた
このことからExpressionクラスのオブジェクトからprintメソッド
を呼び出しても正しくExp_constantのprintメソッドが呼び出され
実行されていることが分かり、ポリモーフィズムが行われている
事も確認できた。

----------------------------------------

[課題5.2]
Exp variable を実装せよ (Exp constant を参考にせよ.)


user@user-THINK /cygdrive/c/programing/Compirer_training/R5a
$ ./a
n

正しく表示されていることが確認できた
この課題でもr5_01の課題でも同じく、クラスが違う者同士の代入
で基底クラス元のメソッドを呼び出しても派生先の意図したクラ
スのメソッドを呼び出すように動作していることが分かった。
このポリモーフィズムという動作は前回の課題では理解だけで
あまりメリットを感じなかったが、この課題や特にR5aの後半の課
題で特に実感することが出来た。

----------------------------------------

[課題5.3]
Exp operation1 を実装せよ

user@user-THINK /cygdrive/c/programing/Compirer_training/R5a
$ ./a
(-n)

正しく表示されていることが確認できた
この課題から、クラスのコンストラクタの引数にオブジェクトを
渡していることから、様々なクラス(Exp_variable, Exp_operatio
nなど)間で階層構造のようなものがあり、階層のひくいクラスか
ら上のクラスにコンストラクタを通じて引き渡していくイメージ
を持った。この構造をast.hやast.cppにプログラムすることで
ここまで完結でわかりやすいmain関数ができることが実感でき、前
回の課題で最後にコメントされた"継承をうまく使いこなす"ことの
重要性を実感できた

---------------------------

[課題5.4]
Exp operation2 を実装せよ.

user@user-THINK /cygdrive/c/programing/Compirer_training/R5a
$ ./a
(n+1) ---①
((n+1)*2) ---②

正しく表示されていることが確認できた
この課題では、Exp_operation2(Exp_operation2, Exp_constant)の
ように同じクラスのオブジェクトをコンストラクタの引数に渡して
いることが分かった。
このように行うことで①で作った式にさらに掛け算を行いたい、と
いう時にも元々作っていた式①を再利用できることが分かった

---------------------------

[課題5.5]
Exp function を実装せよ.

user@user-THINK /cygdrive/c/programing/Compirer_training/R5a
$ ./a
gcd(a, b)

正しく表示されていることが確認できた
この課題で苦戦していたこととして
for(std::list<Expression*>::const_iterator it = args_.begin();
  it != args_.end(); it++) {
    (*it)->print(os);
この分について
　　it->print(os);
としていてエラーに悩まされていた
原因として、これは自分の考えだがiterator事態がポインタ変数
のようなものでそのポインタiteratorがさしている対象もExpres
sion*、つまりExpressionオブジェクトを指すポインタのため、
iteratorはExpressionオブジェクトのポインタのポインタなので
はないかと考えた。それに気付かずにit->print(os)としていた
ためずっとエラーが出ていたのではないかと考察した
実はポインタについてはc言語の課題で習ったが、ポインタのポイ
ンタは使うのが今回初めてであったため(多分)、今回のエラーに
もなかなか気づけなかったのかもしれない。自分の勉強不足を感
じた

---------------------------

[課題5.6]
St assign を実装せよ.

user@user-THINK /cygdrive/c/programing/Compirer_training/R5a
$ ./a
i = 0;
  i = 0;
    i = 0;

正しく動作していることが確認できた
また入力されている分のインデントも行えていることが確認できた
これはast.cppにもともとコーディングされてあったtab関数を使う
だけだったため、実装も簡単であった。引数に入力された分の" "を
""で初期化されてあった文字列に付け加えるプログラムだった。
その後、左辺、右辺を表すオブジェクトがあるかどうかを確認した
あとにそれぞれ表示していることが分かった。

--------------------------

[課題5.7]
St list を実装せよ

ser@user-THINK /cygdrive/c/programing/Compirer_training/R5a
$ ./a
  s = 0;
  i = (-n);

正しく動作していることが確認できた
st_listのprint関数について、最初はlistに収められている式一
つ一つについて右辺、左辺それぞれ与えられているか確認しよう
としたが、そのようなことをしなくてもlistに格納されているSta
tementオブジェクトの派生クラスのSt_assignオブジェクトの中の
print関数でそのチェックは行われているため、結局はiteratorを
つかってlistの走査を行い、各オブジェクトのprint関数を呼び出
せばよいということが分かった。このようなことが出来るのも、
レジュメに書いてあるような整った抽象構文木を作った後にコーデ
ィングを行ったためだと感じた

-----------------------------------------------------------

[R5a全体の感想]
この課題では式の代入や、演算などの順序を考える
↓
その順序を考慮した抽象構文木を作る
↓
その木の階層構造に対応したクラスの継承関係を意識しながら
クラスの定義や実装を行う

という順でプログラミングを行うことの大切さを感じた
そしてそのようなことができるのはcではなくc++だからこそだと
感じた。自分は普段はこんな計画的にコーディングをしていない
ため、この課題で得たことを活用してこのように行えるようにし
ていきたい。
以上の様にこの課題では、コンパイラを学ぶだけでなくc++や、
混乱のない整ったプログラムを作るためのことにも勉強になるた
め非常に有意義であった。

